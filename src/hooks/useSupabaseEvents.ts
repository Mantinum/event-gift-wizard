import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Event } from '@/types';
import { toast } from '@/hooks/use-toast';

export function useSupabaseEvents() {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch events from Supabase
  const fetchEvents = async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        setEvents([]);
        setLoading(false);
        return;
      }

      const { data, error } = await supabase
        .from('events')
        .select('*')
        .eq('user_id', user.id)
        .order('date', { ascending: true });

      if (error) throw error;

      // Transform database format to app format
      const transformedEvents: Event[] = (data || []).map(event => ({
        id: event.id,
        title: event.title,
        date: event.date,
        type: event.type as Event['type'],
        personId: event.person_id || '',
        person: event.person_name,
        budget: event.budget,
        status: event.status as Event['status'],
        description: event.description || '',
        location: event.location || '',
        reminderDays: event.reminder_days || 7,
        isAutoGenerated: event.is_auto_generated || false
      }));

      setEvents(transformedEvents);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
      toast({
        title: "Erreur",
        description: "Impossible de charger les événements",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  // Add or update event
  const saveEvent = async (event: Event, isUpdate = false) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        toast({
          title: "Erreur",
          description: "Vous devez être connecté",
          variant: "destructive"
        });
        return false;
      }

      // Transform app format to database format
      const dbEvent = {
        user_id: user.id,
        title: event.title,
        date: event.date,
        type: event.type,
        person_id: event.personId || null,
        person_name: event.person,
        budget: event.budget,
        status: event.status,
        description: event.description || null,
        location: event.location || null,
        reminder_days: event.reminderDays || 7,
        is_auto_generated: event.isAutoGenerated || false
      };

      if (isUpdate) {
        const { error } = await supabase
          .from('events')
          .update(dbEvent)
          .eq('id', event.id)
          .eq('user_id', user.id);

        if (error) throw error;

        setEvents(prev => prev.map(e => e.id === event.id ? event : e));
        
        toast({
          title: "Succès",
          description: "Événement mis à jour avec succès"
        });
      } else {
        const { data, error } = await supabase
          .from('events')
          .insert(dbEvent)
          .select()
          .single();

        if (error) throw error;

        const newEvent: Event = {
          ...event,
          id: data.id
        };

        setEvents(prev => [...prev, newEvent]);
        
        toast({
          title: "Succès",
          description: "Événement créé avec succès"
        });
      }

      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
      toast({
        title: "Erreur",
        description: isUpdate ? "Impossible de mettre à jour l'événement" : "Impossible de créer l'événement",
        variant: "destructive"
      });
      return false;
    }
  };

  // Delete event
  const deleteEvent = async (eventId: string) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return false;

      const { error } = await supabase
        .from('events')
        .delete()
        .eq('id', eventId)
        .eq('user_id', user.id);

      if (error) throw error;

      setEvents(prev => prev.filter(e => e.id !== eventId));
      
      toast({
        title: "Succès",
        description: "Événement supprimé avec succès"
      });

      return true;
    } catch (err) {
      toast({
        title: "Erreur",
        description: "Impossible de supprimer l'événement",
        variant: "destructive"
      });
      return false;
    }
  };

  // Add multiple events (for auto-generated events)
  const saveMultipleEvents = async (newEvents: Event[]) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return false;

      const dbEvents = newEvents.map(event => ({
        user_id: user.id,
        title: event.title,
        date: event.date,
        type: event.type,
        person_id: event.personId || null,
        person_name: event.person,
        budget: event.budget,
        status: event.status,
        description: event.description || null,
        location: event.location || null,
        reminder_days: event.reminderDays || 7,
        is_auto_generated: event.isAutoGenerated || false
      }));

      const { data, error } = await supabase
        .from('events')
        .insert(dbEvents)
        .select();

      if (error) throw error;

      const createdEvents: Event[] = (data || []).map((dbEvent, index) => ({
        ...newEvents[index],
        id: dbEvent.id
      }));

      setEvents(prev => [...prev, ...createdEvents]);
      return true;
    } catch (err) {
      toast({
        title: "Erreur",
        description: "Impossible de créer les événements automatiques",
        variant: "destructive"
      });
      return false;
    }
  };

  useEffect(() => {
    fetchEvents();

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event) => {
      if (event === 'SIGNED_IN') {
        fetchEvents();
      } else if (event === 'SIGNED_OUT') {
        setEvents([]);
        setLoading(false);
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  return {
    events,
    loading,
    error,
    saveEvent,
    deleteEvent,
    saveMultipleEvents,
    refetch: fetchEvents
  };
}